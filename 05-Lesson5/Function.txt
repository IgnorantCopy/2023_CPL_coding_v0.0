一、过程抽象:将一个功能封装成独立的功能模块
1.基于过程抽象的程序设计:
    ①功能分解:在进行程序设计时,首先把程序的功能分解成若干子功能,每个子功能又可以继续分解成若干子功能,
            从而形成了一种自顶向下(top-down)、逐步精化(step-wise)的设计过程
    ②功能复合:把已有的(子)功能逐步组合成更大的(子)功能,从而形成一种自底向上(bottom-up)的设计过程

二、子程序:实现工程抽象的一种方法
1.作用
    ①实现过程抽象(功能抽象)
    ②封装和信息隐藏的作用
    ③减少重复代码,节省劳动力
2.数据传递
    ①全局变量:所有子程序都能访问到的变量
    ②参数:形参(形式参数) + 实参(实在参数)
        i.值传递:把实参的值复制一份给形参
            >在函数调用时,采用类似变量初始化的形式把实参的值传递给形参
            >在函数执行过程中,通过形参获得实参的值
            >函数体中对形参值的改变不会影响相应实参的值!!!!!!
        ii.地址或引用传递:把实参的地址传递给形参
    ③返回值:返回计算结果

三、C函数
1.定义:用于实现子程序的语言成分
2.格式:
    <返回值类型> <函数名>(<形参列表>) {
        <函数体>
    }
    注: ①形参说明的格式: <类型> <形参名>
        ②返回值类型为void时,表示函数没有返回值
4.函数体:用于实现相应函数的功能
    ①return语句:
        i.格式:
            >return <表达式>;
            >return;
        ii.当函数执行到return语句时,函数立即终止,如果有返回值,将返回值返回
        注: 如果表达式类型与返回值类型不一致,则进行强制类型转换
        iii.作用:
            >返回计算结果
            >结束函数执行
            >确定函数运行状态(如main函数的0, -1)
5.函数的调用
    ①格式: <函数名>(<实参列表>);
    ②要求:实参个数和类型与对应函数的形参相同
    注:除了main函数,程序对函数的调用都是从main开始的;main函数一般由操作系统调用
    ③执行过程
        >计算实参的值(对于多个实参,C未规定计算次序)
        >把实参分别传递给被调用函数的形参
        >执行函数体
        >函数体中执行return语句返回函数调用点,调用点获得返回值(如果有的话)并执行调用之后的操作
6.函数的声明
    ①原因:如果函数定义在本源文件中使用点之后或在其他文件中,则在调用前需要对函数进行声明
    ②格式: extern <返回值类型> <函数名>(<形参列表>);
    注: ①在函数声明中,<形参列表>中可以只列出形参的类型而不写形参名
        ②extern可以省略
6.数组作为函数的参数
    ①一维数组:一般用一维数组的声明(无需指明数组长度)和一个整型变量的定义作为被调用函数的形参
    ②二维数组:一般用二维数组的声明(无需指定行数)和一个整型变量的定义作为被调用函数的形参
    注: ①数组作为函数参数传递数据时，实际传递的是数组在内存的起始位置，函数的形参数组不再分配内存空间，它共享实参数组的内存空间!!!!!!
        ②返回值不能是数组类型，因为数组不能整体操作

四、变量的作用域
1.分类
    ①全局变量:在函数外部定义的变量,一般能被程序中的所有函数使用(除了静态全局变量)
    ②局部变量:在复合语句中定义的变量,只能在定义它们的复合语句中使用
2.变量的生存期
    ①定义:程序运行时一个变量占有内存空间的时间段称为该变量的生存期
    ②类型:
        >静态:从程序开始执行时就进行内存空间分配,直到程序结束才收回它们的空间(如全局变量具有静态生存期)
        >自动:在程序执行到定义它们的复合语句(包括函数体)时才分配内存空间,当定义它们的复合语句执行结束时,
            它们的空间将被收回(局部变量和函数的参数一般具有自动生存期)
        >动态:内存空间在程序中显式地用malloc库函数分配、free库函数收回(动态变量具有动态生存期)
    ③存储类修饰符
        i.声明全局变量:extern
        ii.声明局部变量:
            >auto/缺省:使局部变量具有自动生存期
            >static:使局部变量具有静态生存期,只在函数第一次调用的时候进行初始化,它的值为上一次函数调用结束时的值
            >register:局部变量仍是自动生存期,但由编译程序根据CPU寄存器的使用情况来决定是否存放在寄存器中(未必放内存)

五、程序实体在内存中的安排
1.静态数据区:用于全局变量、static存储类的局部变量以及常量的内存分配
2.代码区:用于存放程序的指令(对于C程序而言,代码区存放的是所有二进制代码)
3.栈区(stack):用于auto存储类的局部变量、函数的形参以及函数调用时有关信息(如函数返回地址等)的内存分配
    由编译器自动分配释放,存放函数的参数值,局部变量的值等,内存的分配是连续的,类似于平时我们所说的栈(可以把它想成数组),
    它的内存分配是连续分配的,即:所分配的内存是在一块连续的内存区域内,当我们声明变量时,编译器会自动接着当前栈区的结尾来分配内存
4.堆区(heap):用于动态变量的内存分配
    一般由程序员分配释放,若程序员不释放,程序结束时可能由操作系统回收,类似于链表,在内存中的分布不是连续的,它们是不同区域的内存块通过指针链接起来的
5.文字常量区:存放常量字符串,程序结束后由系统释放

六、标识符的作用域
1.定义:标识符的有效范围(能被访问的程序段)
2.分类
    ①局部作用域
        >定义:在函数定义或复合语句中,从标识符的定义点开始到函数定义或复合语句结束之前的程序段
        >C中的局部常量名、局部变量名(C++的对象名)以及函数的形参名具有局部作用域
    ②全局作用域
        >在函数级定义的标识符具有全局作用域
        >全局变量名(对象名)、全局函数名和全局类名的作用域一般具有全局作用域,它们在整个程序中可用
        >如果在某个局部作用域中定义了与某个全局标识符同名的标识符,则该全局标识符的作用域应扣掉与之同名的局部标识符的作用域
        >在局部标识符的作用域中若要使用与其同名的全局标识符,则需要用全局域选择符(::)对全局标识符进行修饰(受限)
    ③文件作用域
        >在全局标识符的定义中加上static修饰符,则该全局标识符就成了具有文件作用域的标识符,它们只能在定义它们的源文件(模块)中使用
        >一般情况下,具有全局作用域的标识符主要用于标识被程序各个模块共享的程序实体,而具有文件作用域的标识符用于标识在一个模块内部使用的程序实体
        注:static的含义
        ①在局部变量的定义中,static修饰符用于指定局部变量采用静态存储分配
        ②在全局标识符的定义中,static修饰符用于把全局标识符的作用域改变为文件作用域
    ④函数作用域
        >语句标号是唯一具有函数作用域的标识符,在定义它的函数体中的任何地方都可以访问
        注:函数作用域与局部作用域的区别
        ①函数作用域包括整个函数,而局部作用域是从定义点开始到函数定义或复合语句结束
        ②在函数体中,一个语句标号只能定义一次,即使是在内层的复合语句中,也不能再定义与外层相同的语句标号
    ⑤函数原型作用域
    ⑥类作用域
    ⑦名空间作用域(C++)
        >引入:对于一个由多个文件构成的程序,有时会面临一个问题:在一个源文件中要用到两个分别在另外两个源文件中定义的不同全局程序实体(如:全局函数),
            而这两个全局程序实体的名字相同;所以C++提供了名空间(namespace)设施来解决上述的名冲突问题
        >在一个名空间中定义的全局标识符,其作用域为该名空间
        >当在一个名空间外部需要使用该名空间中定义的全局标识符时,可用该名空间的名字来修饰或受限

七、C++模块构成
1.成分
    ①接口(.h文件):给出在本模块中定义的、提供给其它模块使用的一些程序实体(如:函数、全局变量等)的声明
    ②实现(.cpp文件):模块的实现给出了模块中的程序实体的定义
2.语法
    ①在模块A中要用到模块B中定义的程序实体时,可以在A的.cpp文件中用文件包含命令(#include)把B的.h文件包含进来
    格式为:#include <文件名> or #include "文件名"
    含义:在编译前，用命令中的文件名所指定的文件内容替换该命令
    注:前者从编译器的的自带的头文件库查找;后者编译时从你当前创建的工程寻找文件,找不到时,再查找编译器的的自带的头文件库